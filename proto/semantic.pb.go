// Code generated by protoc-gen-go. DO NOT EDIT.
// source: semantic.proto

/*
Package proto is a generated protocol buffer package.

It is generated from these files:
	semantic.proto

It has these top-level messages:
	SemanticDescriptor
	SemanticMessageDescriptor
*/
package proto

import proto1 "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/protoc-gen-go/descriptor"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto1.ProtoPackageIsVersion2 // please upgrade the proto package

type SemanticDescriptor_Labels int32

const (
	SemanticDescriptor_ADVANCED SemanticDescriptor_Labels = 1
	// only.
	SemanticDescriptor_HIDDEN SemanticDescriptor_Labels = 2
)

var SemanticDescriptor_Labels_name = map[int32]string{
	1: "ADVANCED",
	2: "HIDDEN",
}
var SemanticDescriptor_Labels_value = map[string]int32{
	"ADVANCED": 1,
	"HIDDEN":   2,
}

func (x SemanticDescriptor_Labels) Enum() *SemanticDescriptor_Labels {
	p := new(SemanticDescriptor_Labels)
	*p = x
	return p
}
func (x SemanticDescriptor_Labels) String() string {
	return proto1.EnumName(SemanticDescriptor_Labels_name, int32(x))
}
func (x *SemanticDescriptor_Labels) UnmarshalJSON(data []byte) error {
	value, err := proto1.UnmarshalJSONEnum(SemanticDescriptor_Labels_value, data, "SemanticDescriptor_Labels")
	if err != nil {
		return err
	}
	*x = SemanticDescriptor_Labels(value)
	return nil
}
func (SemanticDescriptor_Labels) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0} }

type SemanticDescriptor struct {
	// The semantic name of the SemanticValue contained in this field.
	Type *string `protobuf:"bytes,1,opt,name=type" json:"type,omitempty"`
	// The type of this field can be specified dynamically. This is the name of
	// the attribute to use to retrieve the SemanticValue class to be used for
	// parsing this field.
	DynamicType *string                     `protobuf:"bytes,5,opt,name=dynamic_type,json=dynamicType" json:"dynamic_type,omitempty"`
	Description *string                     `protobuf:"bytes,2,opt,name=description" json:"description,omitempty"`
	Label       []SemanticDescriptor_Labels `protobuf:"varint,3,rep,name=label,enum=proto.SemanticDescriptor_Labels" json:"label,omitempty"`
	// A friendly name for this field - to be used in GUIs etc.
	FriendlyName     *string `protobuf:"bytes,4,opt,name=friendly_name,json=friendlyName" json:"friendly_name,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *SemanticDescriptor) Reset()                    { *m = SemanticDescriptor{} }
func (m *SemanticDescriptor) String() string            { return proto1.CompactTextString(m) }
func (*SemanticDescriptor) ProtoMessage()               {}
func (*SemanticDescriptor) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *SemanticDescriptor) GetType() string {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return ""
}

func (m *SemanticDescriptor) GetDynamicType() string {
	if m != nil && m.DynamicType != nil {
		return *m.DynamicType
	}
	return ""
}

func (m *SemanticDescriptor) GetDescription() string {
	if m != nil && m.Description != nil {
		return *m.Description
	}
	return ""
}

func (m *SemanticDescriptor) GetLabel() []SemanticDescriptor_Labels {
	if m != nil {
		return m.Label
	}
	return nil
}

func (m *SemanticDescriptor) GetFriendlyName() string {
	if m != nil && m.FriendlyName != nil {
		return *m.FriendlyName
	}
	return ""
}

type SemanticMessageDescriptor struct {
	// Describe the purpose of this protobuf.
	Description *string `protobuf:"bytes,1,opt,name=description" json:"description,omitempty"`
	// Certain RDFValues have union-like semantics. I.e. they are essentially
	// selectors of a number of other predefined RDFValues. They have a single
	// field that identifies the type of the selected "subvalue" and
	// nested fields corresponding to different selections. For examples:
	//
	// message FileFinderFilter {
	//   option (semantic) = {
	//     union_field: "filter_type"
	//   };
	//   enum Type {
	//     MODIFICATION_TIME = 0 [(description) = "Modification time"];
	//     ACCESS_TIME = 1 [(description) = "Access time"];
	//   }
	//
	//   optional Type filter_type = 1;
	//   optional FileFinderModificationTimeFilter modification_time = 2;
	//   optional FileFinderAccessTimeFilter access_time = 3;
	// }
	//
	// Field specified in union_field is used to determine which nested fields is
	// actually used. Field identified by union_field has to be Enum.
	// Corresponding nested values have to have names equal to enum values names,
	// but in lower case.
	//
	// At the moment setting union_field attribute on an RDFValue only affects the
	// UI rendering. RDFValues with union_field set are rendered with a select
	// box that allows users to switch between different available types.
	//
	// TODO(user): Suggestion from bgalehouse: We can just have "is_union"
	// boolean attribute instead of a string "union_field", because for
	// union-like structures we can understand the type of the structure by
	// inspecting its data fields.
	UnionField       *string `protobuf:"bytes,2,opt,name=union_field,json=unionField" json:"union_field,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *SemanticMessageDescriptor) Reset()                    { *m = SemanticMessageDescriptor{} }
func (m *SemanticMessageDescriptor) String() string            { return proto1.CompactTextString(m) }
func (*SemanticMessageDescriptor) ProtoMessage()               {}
func (*SemanticMessageDescriptor) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *SemanticMessageDescriptor) GetDescription() string {
	if m != nil && m.Description != nil {
		return *m.Description
	}
	return ""
}

func (m *SemanticMessageDescriptor) GetUnionField() string {
	if m != nil && m.UnionField != nil {
		return *m.UnionField
	}
	return ""
}

var E_SemType = &proto1.ExtensionDesc{
	ExtendedType:  (*google_protobuf.FieldOptions)(nil),
	ExtensionType: (*SemanticDescriptor)(nil),
	Field:         51584972,
	Name:          "proto.sem_type",
	Tag:           "bytes,51584972,opt,name=sem_type,json=semType",
	Filename:      "semantic.proto",
}

var E_Semantic = &proto1.ExtensionDesc{
	ExtendedType:  (*google_protobuf.MessageOptions)(nil),
	ExtensionType: (*SemanticMessageDescriptor)(nil),
	Field:         51584971,
	Name:          "proto.semantic",
	Tag:           "bytes,51584971,opt,name=semantic",
	Filename:      "semantic.proto",
}

var E_Description = &proto1.ExtensionDesc{
	ExtendedType:  (*google_protobuf.EnumValueOptions)(nil),
	ExtensionType: (*string)(nil),
	Field:         48651165,
	Name:          "proto.description",
	Tag:           "bytes,48651165,opt,name=description",
	Filename:      "semantic.proto",
}

var E_Label = &proto1.ExtensionDesc{
	ExtendedType:  (*google_protobuf.EnumValueOptions)(nil),
	ExtensionType: ([]SemanticDescriptor_Labels)(nil),
	Field:         48651166,
	Name:          "proto.label",
	Tag:           "varint,48651166,rep,name=label,enum=proto.SemanticDescriptor_Labels",
	Filename:      "semantic.proto",
}

func init() {
	proto1.RegisterType((*SemanticDescriptor)(nil), "proto.SemanticDescriptor")
	proto1.RegisterType((*SemanticMessageDescriptor)(nil), "proto.SemanticMessageDescriptor")
	proto1.RegisterEnum("proto.SemanticDescriptor_Labels", SemanticDescriptor_Labels_name, SemanticDescriptor_Labels_value)
	proto1.RegisterExtension(E_SemType)
	proto1.RegisterExtension(E_Semantic)
	proto1.RegisterExtension(E_Description)
	proto1.RegisterExtension(E_Label)
}

func init() { proto1.RegisterFile("semantic.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 376 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x92, 0xcf, 0x4e, 0xf2, 0x40,
	0x14, 0xc5, 0x53, 0xfe, 0x7d, 0x7c, 0xb7, 0x48, 0xc8, 0x6c, 0x2c, 0x26, 0x86, 0x52, 0x37, 0xac,
	0x4a, 0xc2, 0xc2, 0x45, 0x77, 0xc4, 0x42, 0x34, 0x51, 0x4c, 0xaa, 0x61, 0x65, 0xc4, 0x81, 0x0e,
	0x64, 0x92, 0xce, 0x0c, 0xe9, 0xb4, 0x0b, 0x1e, 0xc5, 0x85, 0xbe, 0x86, 0x4b, 0x1f, 0x40, 0x9e,
	0xc5, 0x67, 0x30, 0x9d, 0xb6, 0xa8, 0x34, 0x26, 0xba, 0x6a, 0x7b, 0xef, 0x99, 0xdf, 0xbd, 0xe7,
	0x74, 0xa0, 0x29, 0x09, 0xc3, 0x3c, 0xa2, 0x0b, 0x7b, 0x1d, 0x8a, 0x48, 0xa0, 0xaa, 0x7a, 0x1c,
	0x99, 0x2b, 0x21, 0x56, 0x01, 0xe9, 0xab, 0xaf, 0x79, 0xbc, 0xec, 0xfb, 0x44, 0x2e, 0x42, 0xba,
	0x8e, 0x44, 0x98, 0x0a, 0xad, 0x77, 0x0d, 0xd0, 0x4d, 0x76, 0xd6, 0xdd, 0x35, 0x11, 0x82, 0x4a,
	0xb4, 0x59, 0x13, 0x43, 0x33, 0xb5, 0xde, 0x7f, 0x4f, 0xbd, 0xa3, 0x2e, 0x34, 0xfc, 0x0d, 0xc7,
	0x8c, 0x2e, 0x66, 0xaa, 0x57, 0x55, 0x3d, 0x3d, 0xab, 0xdd, 0x26, 0x12, 0x13, 0xf4, 0x7c, 0x02,
	0x15, 0xdc, 0x28, 0x65, 0x8a, 0xcf, 0x12, 0x3a, 0x85, 0x6a, 0x80, 0xe7, 0x24, 0x30, 0xca, 0x66,
	0xb9, 0xd7, 0x1c, 0x98, 0xe9, 0x1a, 0x76, 0x71, 0x05, 0xfb, 0x32, 0x91, 0x49, 0x2f, 0x95, 0xa3,
	0x13, 0x38, 0x58, 0x86, 0x94, 0x70, 0x3f, 0xd8, 0xcc, 0x38, 0x66, 0xc4, 0xa8, 0x28, 0x76, 0x23,
	0x2f, 0x4e, 0x30, 0x23, 0x96, 0x05, 0xb5, 0xf4, 0x14, 0x6a, 0x40, 0x7d, 0xe8, 0x4e, 0x87, 0x93,
	0xb3, 0x91, 0xdb, 0xd2, 0x10, 0x40, 0xed, 0xfc, 0xc2, 0x75, 0x47, 0x93, 0x56, 0xc9, 0xba, 0x87,
	0x76, 0x3e, 0xec, 0x8a, 0x48, 0x89, 0x57, 0xe4, 0x8b, 0xed, 0xbd, 0xfd, 0xb5, 0xe2, 0xfe, 0x1d,
	0xd0, 0x63, 0x4e, 0x05, 0x9f, 0x2d, 0x29, 0x09, 0xfc, 0xcc, 0x21, 0xa8, 0xd2, 0x38, 0xa9, 0x38,
	0x53, 0xa8, 0x4b, 0xc2, 0x54, 0x42, 0xe8, 0xd8, 0x4e, 0xf3, 0xb7, 0xf3, 0xfc, 0x6d, 0xa5, 0xb9,
	0x56, 0x28, 0x69, 0x6c, 0x5f, 0xb7, 0x86, 0xa9, 0xf5, 0xf4, 0x41, 0xfb, 0xc7, 0x14, 0xbc, 0x7f,
	0x92, 0xb0, 0x24, 0x5a, 0xe7, 0x41, 0x71, 0x55, 0x1b, 0x75, 0x0a, 0xdc, 0xcc, 0x4a, 0x4e, 0x7e,
	0xcb, 0xc9, 0xfb, 0xf9, 0x16, 0x2c, 0x7b, 0x3b, 0xaa, 0x33, 0xfe, 0x66, 0x1e, 0x75, 0x0b, 0x43,
	0x46, 0x3c, 0x66, 0x53, 0x1c, 0xc4, 0xbb, 0x31, 0x4f, 0x2f, 0x8f, 0x87, 0x85, 0x88, 0x9c, 0xbb,
	0xec, 0x17, 0xff, 0x86, 0xf0, 0x9c, 0x10, 0xfe, 0x72, 0x11, 0x3e, 0x02, 0x00, 0x00, 0xff, 0xff,
	0x5b, 0xb7, 0x35, 0x53, 0xea, 0x02, 0x00, 0x00,
}
