// Code generated by protoc-gen-go. DO NOT EDIT.
// source: generic.proto

package proto

import proto1 "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "www.velocidex.com/golang/velociraptor/proto"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type DataBlob_CompressionType int32

const (
	DataBlob_UNCOMPRESSED DataBlob_CompressionType = 0
	// Compressed using the zlib.compress() function.
	DataBlob_ZCOMPRESSION DataBlob_CompressionType = 1
)

var DataBlob_CompressionType_name = map[int32]string{
	0: "UNCOMPRESSED",
	1: "ZCOMPRESSION",
}
var DataBlob_CompressionType_value = map[string]int32{
	"UNCOMPRESSED": 0,
	"ZCOMPRESSION": 1,
}

func (x DataBlob_CompressionType) Enum() *DataBlob_CompressionType {
	p := new(DataBlob_CompressionType)
	*p = x
	return p
}
func (x DataBlob_CompressionType) String() string {
	return proto1.EnumName(DataBlob_CompressionType_name, int32(x))
}
func (x *DataBlob_CompressionType) UnmarshalJSON(data []byte) error {
	value, err := proto1.UnmarshalJSONEnum(DataBlob_CompressionType_value, data, "DataBlob_CompressionType")
	if err != nil {
		return err
	}
	*x = DataBlob_CompressionType(value)
	return nil
}
func (DataBlob_CompressionType) EnumDescriptor() ([]byte, []int) { return fileDescriptor2, []int{0, 0} }

// A generic protobuf to deliver some data
// The data can be a single value a protobuf or a list.
// Next field: 13
type DataBlob struct {
	Integer   *int64            `protobuf:"varint,1,opt,name=integer" json:"integer,omitempty"`
	Data      []byte            `protobuf:"bytes,2,opt,name=data" json:"data,omitempty"`
	String_   *string           `protobuf:"bytes,3,opt,name=string" json:"string,omitempty"`
	ProtoName *string           `protobuf:"bytes,4,opt,name=proto_name,json=protoName" json:"proto_name,omitempty"`
	None      *string           `protobuf:"bytes,5,opt,name=none" json:"none,omitempty"`
	Boolean   *bool             `protobuf:"varint,6,opt,name=boolean" json:"boolean,omitempty"`
	List      *BlobArray        `protobuf:"bytes,8,opt,name=list" json:"list,omitempty"`
	Dict      *Dict             `protobuf:"bytes,9,opt,name=dict" json:"dict,omitempty"`
	RdfValue  *EmbeddedRDFValue `protobuf:"bytes,10,opt,name=rdf_value,json=rdfValue" json:"rdf_value,omitempty"`
	Float     *float32          `protobuf:"fixed32,11,opt,name=float" json:"float,omitempty"`
	Set       *BlobArray        `protobuf:"bytes,12,opt,name=set" json:"set,omitempty"`
	// How the message_list element is compressed
	Compression      *DataBlob_CompressionType `protobuf:"varint,7,opt,name=compression,enum=proto.DataBlob_CompressionType,def=0" json:"compression,omitempty"`
	XXX_unrecognized []byte                    `json:"-"`
}

func (m *DataBlob) Reset()                    { *m = DataBlob{} }
func (m *DataBlob) String() string            { return proto1.CompactTextString(m) }
func (*DataBlob) ProtoMessage()               {}
func (*DataBlob) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0} }

const Default_DataBlob_Compression DataBlob_CompressionType = DataBlob_UNCOMPRESSED

func (m *DataBlob) GetInteger() int64 {
	if m != nil && m.Integer != nil {
		return *m.Integer
	}
	return 0
}

func (m *DataBlob) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *DataBlob) GetString_() string {
	if m != nil && m.String_ != nil {
		return *m.String_
	}
	return ""
}

func (m *DataBlob) GetProtoName() string {
	if m != nil && m.ProtoName != nil {
		return *m.ProtoName
	}
	return ""
}

func (m *DataBlob) GetNone() string {
	if m != nil && m.None != nil {
		return *m.None
	}
	return ""
}

func (m *DataBlob) GetBoolean() bool {
	if m != nil && m.Boolean != nil {
		return *m.Boolean
	}
	return false
}

func (m *DataBlob) GetList() *BlobArray {
	if m != nil {
		return m.List
	}
	return nil
}

func (m *DataBlob) GetDict() *Dict {
	if m != nil {
		return m.Dict
	}
	return nil
}

func (m *DataBlob) GetRdfValue() *EmbeddedRDFValue {
	if m != nil {
		return m.RdfValue
	}
	return nil
}

func (m *DataBlob) GetFloat() float32 {
	if m != nil && m.Float != nil {
		return *m.Float
	}
	return 0
}

func (m *DataBlob) GetSet() *BlobArray {
	if m != nil {
		return m.Set
	}
	return nil
}

func (m *DataBlob) GetCompression() DataBlob_CompressionType {
	if m != nil && m.Compression != nil {
		return *m.Compression
	}
	return Default_DataBlob_Compression
}

// A generic collection of blobs
type BlobArray struct {
	Content          []*DataBlob `protobuf:"bytes,1,rep,name=content" json:"content,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *BlobArray) Reset()                    { *m = BlobArray{} }
func (m *BlobArray) String() string            { return proto1.CompactTextString(m) }
func (*BlobArray) ProtoMessage()               {}
func (*BlobArray) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{1} }

func (m *BlobArray) GetContent() []*DataBlob {
	if m != nil {
		return m.Content
	}
	return nil
}

// A Key Value pair
type KeyValue struct {
	K                *DataBlob `protobuf:"bytes,1,opt,name=k" json:"k,omitempty"`
	V                *DataBlob `protobuf:"bytes,2,opt,name=v" json:"v,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *KeyValue) Reset()                    { *m = KeyValue{} }
func (m *KeyValue) String() string            { return proto1.CompactTextString(m) }
func (*KeyValue) ProtoMessage()               {}
func (*KeyValue) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{2} }

func (m *KeyValue) GetK() *DataBlob {
	if m != nil {
		return m.K
	}
	return nil
}

func (m *KeyValue) GetV() *DataBlob {
	if m != nil {
		return m.V
	}
	return nil
}

// A list of Key Value pairs
type Dict struct {
	Dat              []*KeyValue `protobuf:"bytes,1,rep,name=dat" json:"dat,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *Dict) Reset()                    { *m = Dict{} }
func (m *Dict) String() string            { return proto1.CompactTextString(m) }
func (*Dict) ProtoMessage()               {}
func (*Dict) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{3} }

func (m *Dict) GetDat() []*KeyValue {
	if m != nil {
		return m.Dat
	}
	return nil
}

// This is a way to serialize an arbitrary RDFValue.
type EmbeddedRDFValue struct {
	EmbeddedAge *uint64 `protobuf:"varint,1,opt,name=embedded_age,json=embeddedAge" json:"embedded_age,omitempty"`
	Name        *string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// retrieve the class for it.
	Data             []byte `protobuf:"bytes,3,opt,name=data" json:"data,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *EmbeddedRDFValue) Reset()                    { *m = EmbeddedRDFValue{} }
func (m *EmbeddedRDFValue) String() string            { return proto1.CompactTextString(m) }
func (*EmbeddedRDFValue) ProtoMessage()               {}
func (*EmbeddedRDFValue) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{4} }

func (m *EmbeddedRDFValue) GetEmbeddedAge() uint64 {
	if m != nil && m.EmbeddedAge != nil {
		return *m.EmbeddedAge
	}
	return 0
}

func (m *EmbeddedRDFValue) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *EmbeddedRDFValue) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func init() {
	proto1.RegisterType((*DataBlob)(nil), "proto.DataBlob")
	proto1.RegisterType((*BlobArray)(nil), "proto.BlobArray")
	proto1.RegisterType((*KeyValue)(nil), "proto.KeyValue")
	proto1.RegisterType((*Dict)(nil), "proto.Dict")
	proto1.RegisterType((*EmbeddedRDFValue)(nil), "proto.EmbeddedRDFValue")
	proto1.RegisterEnum("proto.DataBlob_CompressionType", DataBlob_CompressionType_name, DataBlob_CompressionType_value)
}

func init() { proto1.RegisterFile("generic.proto", fileDescriptor2) }

var fileDescriptor2 = []byte{
	// 565 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x53, 0xd1, 0x6e, 0xd3, 0x30,
	0x14, 0xc5, 0x6b, 0xb6, 0xb5, 0x37, 0x85, 0x55, 0x16, 0x1a, 0x06, 0x69, 0xcc, 0x8a, 0x86, 0x08,
	0x0f, 0xa4, 0xd2, 0x24, 0x78, 0xd8, 0xdb, 0xba, 0x6e, 0x80, 0x10, 0x2b, 0x78, 0x83, 0x07, 0x5e,
	0x26, 0x37, 0xb9, 0xcd, 0xa2, 0x25, 0x76, 0xe5, 0x98, 0x8e, 0x7e, 0x03, 0xe2, 0xaf, 0xf8, 0x12,
	0xf8, 0x0d, 0x1e, 0x50, 0xdc, 0x84, 0x95, 0x6a, 0x3c, 0xd5, 0xf7, 0x9e, 0xd3, 0x73, 0xaf, 0x73,
	0x8e, 0xe1, 0x6e, 0x8a, 0x0a, 0x4d, 0x16, 0x47, 0x53, 0xa3, 0xad, 0xa6, 0xeb, 0xee, 0xe7, 0xd1,
	0xc1, 0xf5, 0xf5, 0x75, 0x34, 0xc3, 0x5c, 0xc7, 0x59, 0x82, 0x5f, 0xa3, 0x58, 0x17, 0xfd, 0x54,
	0xe7, 0x52, 0xa5, 0xfd, 0x45, 0xd3, 0xc8, 0xa9, 0xd5, 0xa6, 0xef, 0xc8, 0xfd, 0x12, 0x0b, 0xa9,
	0x6c, 0x23, 0x11, 0x7c, 0xf3, 0xa0, 0x3d, 0x94, 0x56, 0x0e, 0x72, 0x3d, 0xa6, 0x0c, 0x36, 0x33,
	0x65, 0x31, 0x45, 0xc3, 0x08, 0x27, 0x61, 0x4b, 0x34, 0x25, 0xa5, 0xe0, 0x25, 0xd2, 0x4a, 0xb6,
	0xc6, 0x49, 0xd8, 0x15, 0xee, 0x4c, 0xb7, 0x61, 0xa3, 0xb4, 0x26, 0x53, 0x29, 0x6b, 0x71, 0x12,
	0x76, 0x44, 0x5d, 0xd1, 0x1d, 0x00, 0xa7, 0x7d, 0xa1, 0x64, 0x81, 0xcc, 0x73, 0x58, 0xc7, 0x75,
	0x4e, 0x65, 0x81, 0x95, 0x94, 0xd2, 0x0a, 0xd9, 0xba, 0x03, 0xdc, 0xb9, 0x1a, 0x3c, 0xd6, 0x3a,
	0x47, 0xa9, 0xd8, 0x06, 0x27, 0x61, 0x5b, 0x34, 0x25, 0xdd, 0x03, 0x2f, 0xcf, 0x4a, 0xcb, 0xda,
	0x9c, 0x84, 0xfe, 0x7e, 0x6f, 0xb1, 0x75, 0x54, 0x6d, 0x7b, 0x68, 0x8c, 0x9c, 0x0b, 0x87, 0xd2,
	0x5d, 0xf0, 0x92, 0x2c, 0xb6, 0xac, 0xe3, 0x58, 0x7e, 0xcd, 0x1a, 0x66, 0xb1, 0x15, 0x0e, 0xa0,
	0x31, 0x74, 0x4c, 0x32, 0xb9, 0x98, 0xc9, 0xfc, 0x0b, 0x32, 0x70, 0xac, 0x07, 0x35, 0xeb, 0xb8,
	0x18, 0x63, 0x92, 0x60, 0x22, 0x86, 0x27, 0x9f, 0x2a, 0x78, 0xf0, 0xfc, 0xe7, 0xef, 0x5f, 0x3f,
	0xc8, 0x53, 0xfa, 0xe4, 0xcc, 0x6a, 0x83, 0x5c, 0x2a, 0x8e, 0x35, 0x85, 0x4b, 0x33, 0xce, 0xac,
	0x91, 0x66, 0xce, 0x1b, 0x76, 0x24, 0xda, 0x26, 0x99, 0xb8, 0x23, 0xbd, 0x0f, 0xeb, 0x93, 0x5c,
	0x4b, 0xcb, 0x7c, 0x4e, 0xc2, 0x35, 0xb1, 0x28, 0x68, 0x00, 0xad, 0x12, 0x2d, 0xeb, 0xfe, 0xe7,
	0x02, 0x15, 0x48, 0x47, 0xe0, 0xc7, 0xba, 0x98, 0x1a, 0x2c, 0xcb, 0x4c, 0x2b, 0xb6, 0xc9, 0x49,
	0x78, 0x6f, 0x7f, 0xb7, 0xb9, 0x46, 0x6d, 0x4f, 0x74, 0x74, 0x43, 0x39, 0x9f, 0x4f, 0xf1, 0xa0,
	0xfb, 0xf1, 0xf4, 0x68, 0xf4, 0xee, 0xbd, 0x38, 0x3e, 0x3b, 0x3b, 0x1e, 0x8a, 0x65, 0x85, 0xe0,
	0x05, 0x6c, 0xad, 0xb0, 0x69, 0x0f, 0xfe, 0xe1, 0xf7, 0xee, 0x54, 0x9d, 0xcf, 0x4d, 0xe3, 0xcd,
	0xe8, 0xb4, 0x47, 0x82, 0x97, 0xd0, 0xf9, 0xbb, 0x19, 0x7d, 0x06, 0x9b, 0xb1, 0x56, 0x16, 0x95,
	0x65, 0x84, 0xb7, 0x42, 0x7f, 0x7f, 0x6b, 0x65, 0x21, 0xd1, 0xe0, 0xc1, 0x6b, 0x68, 0xbf, 0xc5,
	0xf9, 0xe2, 0x2b, 0xec, 0x00, 0xb9, 0x72, 0xf1, 0xb9, 0xe5, 0x0f, 0xe4, 0xaa, 0x82, 0x67, 0x2e,
	0x46, 0xb7, 0xc1, 0xb3, 0x60, 0x04, 0x5e, 0x65, 0x1b, 0x7d, 0x05, 0xad, 0x44, 0xae, 0x0e, 0x6e,
	0x66, 0x0c, 0xf6, 0x9c, 0x45, 0x8f, 0xe9, 0xf6, 0xa1, 0x5a, 0xf2, 0xe4, 0x0a, 0xe7, 0x7d, 0xe7,
	0x70, 0xe0, 0x55, 0x92, 0xa2, 0x52, 0x08, 0xbe, 0x13, 0xe8, 0xad, 0x5a, 0x4c, 0x3f, 0x40, 0xb7,
	0xf1, 0xf4, 0x42, 0xa6, 0xe8, 0xd6, 0xf5, 0x06, 0x91, 0x53, 0x0d, 0xc1, 0x17, 0xc3, 0x93, 0xa1,
	0xb4, 0x68, 0xb3, 0x02, 0xe9, 0xc3, 0xf3, 0x4b, 0xe4, 0x32, 0x45, 0xae, 0x27, 0xdc, 0x5e, 0x66,
	0xe5, 0x92, 0xf3, 0x7e, 0xa3, 0x71, 0x98, 0x2e, 0x62, 0x5d, 0xe5, 0x7d, 0xad, 0x8e, 0x75, 0x1d,
	0x75, 0xf7, 0x6a, 0x5a, 0x37, 0xaf, 0xe6, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x73, 0x1c, 0x6a,
	0xa3, 0xc3, 0x03, 0x00, 0x00,
}
